#!/usr/bin/env python3
"""
Visualize displacement results from NumPy .npz files generated by the chunked displacement computation.
Creates UTM-coordinate plots similar to the MATLAB result plotter.

Usage:
    python plot_npz_results.py displacement_results_chunked_2014to2016.npz
    python plot_npz_results.py displacement_results_chunked_2014to2016.npz --outdir plots --show
    python plot_npz_results.py displacement_results_chunked_2014to2016.npz --median-filter-size 5
    python plot_npz_results.py displacement_results_chunked_2014to2016.npz --median-filter-size 0  # disable filter
"""

import numpy as np
import matplotlib.pyplot as plt
from pyproj import Transformer
import argparse
import os
import matplotlib
from matplotlib.colors import ListedColormap
from mpl_toolkits.axes_grid1 import make_axes_locatable
from scipy.ndimage import median_filter

def parse_args():
    p = argparse.ArgumentParser(description='Visualize displacement results from .npz files')
    p.add_argument('npz_file', help='path to .npz file with displacement results')
    p.add_argument('--outdir', default='plots', help='directory to save PNG(s)')
    p.add_argument('--show', action='store_true', help='show plot interactively instead of saving')
    p.add_argument('--grid-size-override', type=float, help='override grid size for plotting (meters)')
    p.add_argument('--median-filter-size', type=int, default=3, 
                   help='median filter kernel size (odd integer, e.g., 3, 5, 7). Use 0 to disable. Default: 3')
    return p.parse_args()

def load_npz_data(npz_file):
    """Load and extract data from the .npz file."""
    print(f"Loading file: {npz_file}")
    
    data = np.load(npz_file)
    
    # Extract the saved arrays
    grid_centers = data['grid_centers']          # Shape: (N, 2) - X,Y coordinates
    displacements = data['displacements']        # Shape: (N, 3) - dx,dy,dz vectors
    displacement_magnitudes = data['displacement_magnitudes']  # Shape: (N,)
    grid_size = float(data['grid_size'])         # Grid cell size in meters
    
    # Optional fields
    offset1 = data.get('offset1', np.array([0, 0, 0]))
    offset2 = data.get('offset2', np.array([0, 0, 0]))
    
    print(f"Loaded {len(grid_centers)} displacement measurements")
    print(f"Grid centers shape: {grid_centers.shape}")
    print(f"Displacements shape: {displacements.shape}")
    print(f"Grid size: {grid_size:.3f} meters")
    
    return grid_centers, displacements, displacement_magnitudes, grid_size, offset1, offset2

def create_regular_grid(grid_centers, displacements, grid_size):
    """Create regular 2D grids for plotting from scattered data points."""
    
    # Extract coordinates and displacement components
    x_coords = grid_centers[:, 0]
    y_coords = grid_centers[:, 1]
    disp_x = displacements[:, 0]  # E-W displacement
    disp_y = displacements[:, 1]  # N-S displacement  
    disp_z = displacements[:, 2]  # Vertical displacement
    
    print("Creating regular grid for visualization...")
    
    # Create regular grid bounds
    x_min, x_max = np.min(x_coords), np.max(x_coords)
    y_min, y_max = np.min(y_coords), np.max(y_coords)
    
    print(f"Coordinate bounds: X({x_min:.1f}-{x_max:.1f}), Y({y_min:.1f}-{y_max:.1f})")
    
    # Create grid edges based on grid size
    x_edges = np.arange(x_min - grid_size/2, x_max + grid_size, grid_size)
    y_edges = np.arange(y_min - grid_size/2, y_max + grid_size, grid_size)
    
    print(f"Grid dimensions: {len(x_edges)-1} x {len(y_edges)-1} cells")
    
    # Initialize grid arrays
    grid_shape = (len(y_edges)-1, len(x_edges)-1)
    grid_dx = np.full(grid_shape, np.nan)
    grid_dy = np.full(grid_shape, np.nan) 
    grid_dz = np.full(grid_shape, np.nan)
    
    # Fill grid arrays
    print("Filling grid arrays...")
    for i, (x, y) in enumerate(zip(x_coords, y_coords)):
        # Find grid indices
        xi = np.digitize(x, x_edges) - 1
        yi = np.digitize(y, y_edges) - 1
        
        # Check bounds
        if 0 <= xi < grid_shape[1] and 0 <= yi < grid_shape[0]:
            grid_dx[yi, xi] = disp_x[i]
            grid_dy[yi, xi] = disp_y[i]
            grid_dz[yi, xi] = disp_z[i]
    
    # Create extent for imshow (normalized to start from 0,0)
    #extent_width = x_max - x_min
    #extent_height = y_max - y_min

    extent_width  = (x_max - x_min) + grid_size
    extent_height = (y_max - y_min) + grid_size
    extent_normalized = (0, extent_width, 0, extent_height)
    
    print(f"Plot extent (meters): {extent_width:.1f} x {extent_height:.1f}")
    print(f"Origin offset: X({x_min:.1f}), Y({y_min:.1f})")
    
    extent_utm = [x_min, x_max, y_min, y_max]
    print(f"Plot extent (UTM meters): X=[{x_min:.3f}, {x_max:.3f}], Y=[{y_min:.3f}, {y_max:.3f}]")

    return grid_dx, grid_dy, grid_dz, extent_normalized, (x_min, y_min)

def apply_median_filter(grid_dx, grid_dy, grid_dz, filter_size):
    """Apply median filter to displacement grids to reduce noise.
    
    Args:
        grid_dx, grid_dy, grid_dz: 2D displacement grids
        filter_size: kernel size (odd integer). If 0 or 1, no filtering is applied.
    
    Returns:
        Filtered displacement grids
    """
    if filter_size <= 1:
        print("Median filter disabled")
        return grid_dx, grid_dy, grid_dz
    
    print(f"Applying median filter with kernel size {filter_size}x{filter_size}...")
    
    # Create a mask for valid (non-NaN) data
    mask_dx = ~np.isnan(grid_dx)
    mask_dy = ~np.isnan(grid_dy)
    mask_dz = ~np.isnan(grid_dz)
    
    # Apply median filter to each component
    # Note: median_filter treats NaNs as very large values, so we need to handle them carefully
    filtered_dx = grid_dx.copy()
    filtered_dy = grid_dy.copy()
    filtered_dz = grid_dz.copy()
    
    # Only filter where we have valid data
    if np.any(mask_dx):
        # Replace NaNs with 0 temporarily for filtering
        temp_dx = np.nan_to_num(grid_dx, nan=0.0)
        temp_dy = np.nan_to_num(grid_dy, nan=0.0)
        temp_dz = np.nan_to_num(grid_dz, nan=0.0)
        
        # Apply median filter
        filtered_dx = median_filter(temp_dx, size=filter_size, mode='constant', cval=0.0)
        filtered_dy = median_filter(temp_dy, size=filter_size, mode='constant', cval=0.0)
        filtered_dz = median_filter(temp_dz, size=filter_size, mode='constant', cval=0.0)
        
        # Restore NaNs where original data was NaN
        filtered_dx[~mask_dx] = np.nan
        filtered_dy[~mask_dy] = np.nan
        filtered_dz[~mask_dz] = np.nan
    
    print("Median filtering complete")
    return filtered_dx, filtered_dy, filtered_dz

def create_displacement_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset, output_path=None):
    """Create the 3-panel displacement visualization."""
    
    print("Creating displacement plot...")
    
    # Compute color limits from all components
    all_values = np.concatenate([grid_dx.flatten(), grid_dy.flatten(), grid_dz.flatten()])
    all_values = all_values[~np.isnan(all_values)]
    
    if len(all_values) > 0:
        #max_abs = np.percentile(np.abs(all_values), 95)  # Use 95th percentile to avoid outliers
        vmin, vmax = -3, 3
    else:
        vmin, vmax = -1, 1
    
    # Ensure reasonable limits
    if vmax < 0.01:  # Less than 1cm
        vmax = 0.1
        vmin = -vmax
    
    print(f"Color scale: {vmin:.3f} to {vmax:.3f} meters")
    
    # Create figure
    fig, axs = plt.subplots(1, 3, figsize=(10, 7), sharey=True)
    
    # Custom colormap (blue-white-red)
    N = 256
    half = N // 2
    cmap_bwr = np.vstack((
        np.column_stack((np.linspace(0,1,half), np.linspace(0,1,half), np.ones(half))),
        np.column_stack((np.ones(N-half), np.linspace(1,0,N-half), np.linspace(1,0,N-half)))
    ))
    bwr_cmap = ListedColormap(cmap_bwr[::-1])  # Reverse: blue=positive, red=negative
    
    # Plot E-W displacement
    im_dx = axs[0].imshow(grid_dx, origin='lower', extent=extent,
                          cmap=bwr_cmap, vmin=vmin, vmax=vmax, interpolation='nearest')
    axs[0].set_xlabel('Relative Easting (m)', fontsize=16)
    axs[0].set_ylabel('Relative Northing (m)', fontsize=16)
    axs[0].set_aspect('equal')
    #axs[0].set_title('E-W Displacement')
    
    # Plot N-S displacement
    im_dy = axs[1].imshow(grid_dy, origin='lower', extent=extent,
                          cmap=bwr_cmap, vmin=vmin, vmax=vmax, interpolation='nearest')
    axs[1].set_xlabel('Relative Easting (m)', fontsize=16)
    axs[1].set_aspect('equal')
    #axs[1].set_title('N-S Displacement')
    
    # Plot vertical displacement
    im_dz = axs[2].imshow(grid_dz, origin='lower', extent=extent,
                          cmap=bwr_cmap, vmin=vmin, vmax=vmax, interpolation='nearest')
    axs[2].set_xlabel('Relative Easting (m)', fontsize=16)
    axs[2].set_aspect('equal')
    #axs[2].set_title('Vertical Displacement')
    
    # Adjust layout
    plt.subplots_adjust(left=0.06, right=0.98, top=0.85, bottom=0.12, wspace=0.05)
    
    # Add colorbars above each subplot
    for ax, im, label in zip(axs, [im_dx, im_dy, im_dz], ['E-W', 'N-S', 'Vertical']):
        pos = ax.get_position()
        cax = fig.add_axes([pos.x0, pos.y0 + pos.height + 0.02, pos.width, 0.03])
        cb = fig.colorbar(im, cax=cax, orientation='horizontal')
        cb.ax.xaxis.set_label_position('top')
        cb.ax.xaxis.set_ticks_position('top')
        cb.set_label(f'{label} (m)', labelpad=2, fontsize=16)
        cb.ax.tick_params(labelsize=16)
    
    # Set tick label size
    for ax in axs:
        ax.tick_params(axis='both', which='major', labelsize=16)
    
    # Save or show
    if output_path:
        plt.savefig(output_path, dpi=200, bbox_inches='tight')
        print(f'Saved displacement plot: {output_path}')
        plt.close()
    else:
        plt.show()

def create_magnitude_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset, output_path=None):
    """Create a magnitude plot from filtered displacement grids using imshow."""
    
    print("Creating magnitude plot from filtered displacements...")
    
    # Compute total displacement magnitude grid from filtered components
    #mag_grid = np.sqrt(grid_dx**2 + grid_dy**2 + grid_dz**2)
    mag_grid = np.sqrt(grid_dx**2 + grid_dy**2)

    fig, ax = plt.subplots(figsize=(8, 6))
    
    # Plot as image (like the displacement components)
    im = ax.imshow(mag_grid, origin='lower', extent=extent,
                   cmap='viridis', vmin=0, vmax=3, interpolation='nearest')

    ax.set_xlabel('Relative Easting (m)', fontsize=16)
    ax.set_ylabel('Relative Northing (m)', fontsize=16)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    
    # Set axis limits to start from 0
    ax.set_xlim(0, extent[1])
    ax.set_ylim(0, extent[3])
    
    # Set tick label size
    ax.tick_params(axis='both', which='major', labelsize=16)
    
    # Add colorbar
    cbar = plt.colorbar(im, ax=ax)
    cbar.set_label('Total Displacement (m)', fontsize=16)
    cbar.ax.tick_params(labelsize=16)
    
    # Add statistics (computed from filtered grid)
    valid_values = mag_grid[~np.isnan(mag_grid)]
    stats_text = f'Mean: {np.nanmean(mag_grid):.3f}m\n'
    stats_text += f'Max: {np.nanmax(mag_grid):.3f}m\n'
    stats_text += f'Points: {len(valid_values)}'
    
    # Adjust the position of the statistics box
    ax.text(0.02, 1.02, stats_text, transform=ax.transAxes, 
            verticalalignment='top', bbox=dict(boxstyle='round', facecolor='white', alpha=0.8))
    
    plt.tight_layout()
    
    # Save or show
    if output_path:
        plt.savefig(output_path, dpi=200, bbox_inches='tight')
        print(f'Saved magnitude plot: {output_path}')
        plt.close()
    else:
        plt.show()

def main():
    args = parse_args()
    
    # Set backend for non-interactive use
    if not args.show:
        matplotlib.use('Agg')
    
    # Load data
    grid_centers, displacements, displacement_magnitudes, grid_size, offset1, offset2 = load_npz_data(args.npz_file)
    
    # Override grid size if specified
    if args.grid_size_override:
        grid_size = args.grid_size_override
        print(f"Using override grid size: {grid_size} meters")
    
    # Create regular grids for plotting
    grid_dx, grid_dy, grid_dz, extent, origin_offset = create_regular_grid(
        grid_centers, displacements, grid_size)
    
    # Apply median filter if requested
    if args.median_filter_size > 0:
        grid_dx, grid_dy, grid_dz = apply_median_filter(
            grid_dx, grid_dy, grid_dz, args.median_filter_size)
    
    # Set up output directory
    if args.outdir == 'plots' or not os.path.isabs(args.outdir):
        npz_dir = os.path.dirname(os.path.abspath(args.npz_file))
        outdir = os.path.join(npz_dir, args.outdir)
    else:
        outdir = args.outdir
    
    os.makedirs(outdir, exist_ok=True)
    base_name = os.path.splitext(os.path.basename(args.npz_file))[0]
    
    # Create displacement plot
    if args.show:
        create_displacement_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset)
    else:
        displacement_output = os.path.join(outdir, f'{base_name}_displacement.png')
        create_displacement_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset, displacement_output)
    
    # Create magnitude plot from filtered displacement grids
    if args.show:
        create_magnitude_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset)
    else:
        magnitude_output = os.path.join(outdir, f'{base_name}_magnitude.png')
        create_magnitude_plot(grid_dx, grid_dy, grid_dz, extent, origin_offset, magnitude_output)
    
    print("Visualization completed successfully!")

if __name__ == "__main__":
    main()
